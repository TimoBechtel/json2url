{"version":3,"file":"index.umd.js","sources":["../../src/Json2Url.js"],"sourcesContent":["export const serialize = (\n  object,\n  {\n    objectPrefix = '=',\n    objectPostfix = '+',\n    separator = '&',\n    emptyPlaceholder = ',',\n    encoder = encodeURIComponent,\n  } = {}\n) => {\n  const escapeRegEx = string => string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  const prefixEscaped = escapeRegEx(objectPrefix);\n  const postfixEscaped = escapeRegEx(objectPostfix);\n  const separatorEscaped = escapeRegEx(separator);\n  const emptyEscaped = escapeRegEx(emptyPlaceholder);\n  if (typeof object === 'string') object = JSON.parse(object);\n  const string = Object.values(object)\n    .map(function encodeValues(value) {\n      if (value && typeof value === 'object') {\n        return (\n          objectPrefix +\n          Object.values(value)\n            .map(encodeValues)\n            .join(separator) +\n          objectPostfix\n        );\n      }\n      if (!value && value !== 0) value = emptyPlaceholder;\n      else {\n        if (value === true) value = 1;\n        value = encoder(value);\n        if (\n          value.match(\n            `(${postfixEscaped})|(${prefixEscaped})|(${separatorEscaped})|(${emptyEscaped})`\n          )\n        )\n          throw `Defined postfix, prefix or separator exists in source! (value: ${value})`;\n      }\n      return value;\n    })\n    .join(separator)\n    .replace(\n      // last postfixes are not needed\n      new RegExp(`${postfixEscaped}+$`),\n      ''\n    )\n    .replace(\n      // prefix / postfix can act as sole separator\n      new RegExp(`${separatorEscaped}${prefixEscaped}`, 'g'),\n      objectPrefix\n    )\n    .replace(\n      new RegExp(`${postfixEscaped}${separatorEscaped}`, 'g'),\n      objectPostfix\n    );\n  return string;\n};\n\nexport const deserialize = (\n  string,\n  template,\n  {\n    objectPrefix = '=',\n    objectPostfix = '+',\n    separator = '&',\n    emptyPlaceholder = ',',\n    decoder = decodeURIComponent,\n  } = {}\n) => {\n  let arrays = [[]];\n  let curArray = arrays[0];\n  let curValue = '';\n  for (const c of string) {\n    if ([separator, objectPrefix, objectPostfix].indexOf(c) !== -1) {\n      if (curValue === emptyPlaceholder) curArray.push('');\n      else if (curValue) curArray.push(decoder(curValue));\n      curValue = '';\n\n      if (c === objectPrefix) {\n        curArray = [];\n        arrays.push(curArray);\n      } else if (c === objectPostfix) {\n        arrays.pop();\n        arrays[arrays.length - 1].push(curArray);\n        curArray = arrays[arrays.length - 1];\n      }\n      continue;\n    }\n    curValue += c;\n  }\n  // if last objectPostfixes are missing\n  if (curValue === emptyPlaceholder) curArray.push('');\n  else if (curValue) curArray.push(decoder(curValue));\n\n  while (arrays.length > 1) arrays[arrays.length - 2].push(arrays.pop());\n\n  // remove outer array\n  arrays = arrays[0];\n\n  if (template) {\n    let object;\n    if (Array.isArray(template)) object = [...template];\n    else object = { ...template };\n    const mapValuesToObject = (object, array) => {\n      Object.entries(object).forEach(([key, value], i) => {\n        if (value && typeof value === 'object') {\n          mapValuesToObject(value, array[i]);\n          return;\n        }\n\n        object[key] = array[i];\n        if (typeof value === 'number') object[key] = parseFloat(array[i]) || 0;\n        else if (typeof value === 'boolean') object[key] = !!array[i];\n      });\n    };\n    mapValuesToObject(object, arrays);\n    return object;\n  }\n\n  return arrays;\n};\n"],"names":["object","encodeURIComponent","escapeRegEx","string","replace","prefixEscaped","objectPrefix","postfixEscaped","objectPostfix","separatorEscaped","separator","emptyEscaped","emptyPlaceholder","JSON","parse","Object","values","map","encodeValues","value","join","encoder","match","RegExp","template","decodeURIComponent","arrays","curArray","curValue","const","c","indexOf","push","decoder","pop","length","Array","isArray","mapValuesToObject","array","entries","forEach","i","key","parseFloat"],"mappings":"mMACEA,oBAOI,wCALa,0CACC,sCACJ,6CACO,oCACTC,wBAGNC,WAAcC,UAAUA,EAAOC,QAAQ,sBAAuB,SAC9DC,EAAgBH,EAAYI,GAC5BC,EAAiBL,EAAYM,GAC7BC,EAAmBP,EAAYQ,GAC/BC,EAAeT,EAAYU,SACX,iBAAXZ,IAAqBA,EAASa,KAAKC,MAAMd,IACrCe,OAAOC,OAAOhB,GAC1BiB,IAAI,SAASC,EAAaC,MACrBA,GAA0B,iBAAVA,SAEhBb,EACAS,OAAOC,OAAOG,GACXF,IAAIC,GACJE,KAAKV,GACRF,KAGCW,GAAmB,IAAVA,OAEE,IAAVA,IAAgBA,EAAQ,IAC5BA,EAAQE,EAAQF,IAERG,UACAf,QAAoBF,QAAmBI,QAAsBE,OAGnE,uEAAwEQ,WATjDA,EAAQP,SAW5BO,IAERC,KAAKV,GACLN,YAEKmB,OAAUhB,QACd,IAEDH,YAEKmB,UAAUd,EAAmBJ,EAAiB,KAClDC,GAEDF,QACC,IAAImB,UAAUhB,EAAiBE,EAAoB,KACnDD,2BAMJL,EACAqB,oBAOI,wCALa,0CACC,sCACJ,6CACO,oCACTC,4BAGRC,EAAS,CAAC,IACVC,EAAWD,EAAO,GAClBE,EAAW,SACCzB,kBAAQ,CAAnB0B,IAAMC,QACoD,IAAzD,CAACpB,EAAWJ,EAAcE,GAAeuB,QAAQD,GAerDF,GAAYE,GAdNF,IAAahB,EAAkBe,EAASK,KAAK,IACxCJ,GAAUD,EAASK,KAAKC,EAAQL,IACzCA,EAAW,GAEPE,IAAMxB,EAERoB,EAAOM,KADPL,EAAW,IAEFG,IAAMtB,IACfkB,EAAOQ,MACPR,EAAOA,EAAOS,OAAS,GAAGH,KAAKL,GAC/BA,EAAWD,EAAOA,EAAOS,OAAS,SAOpCP,IAAahB,EAAkBe,EAASK,KAAK,IACxCJ,GAAUD,EAASK,KAAKC,EAAQL,IAElCF,EAAOS,OAAS,GAAGT,EAAOA,EAAOS,OAAS,GAAGH,KAAKN,EAAOQ,UAGhER,EAASA,EAAO,GAEZF,EAAU,KACRxB,EACyBA,EAAzBoC,MAAMC,QAAQb,GAAoB,UAAIA,GAC5BT,iBAAKS,OACbc,WAAqBtC,EAAQuC,GACjCxB,OAAOyB,QAAQxC,GAAQyC,mBAAuBC,qBACxCvB,GAA0B,iBAAVA,EAClBmB,EAAkBnB,EAAOoB,EAAMG,KAIjC1C,EAAO2C,GAAOJ,EAAMG,GACC,iBAAVvB,EAAoBnB,EAAO2C,GAAOC,WAAWL,EAAMG,KAAO,EAC3C,kBAAVvB,IAAqBnB,EAAO2C,KAASJ,EAAMG,eAG/DJ,EAAkBtC,EAAQ0B,GACnB1B,SAGF0B"}