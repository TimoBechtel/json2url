{"version":3,"file":"index.umd.js","sources":["../../src/Json2Url.js"],"sourcesContent":["export const serialize = (\n  object,\n  {\n    objectPrefix = '=',\n    objectPostfix = '+',\n    separator = '&',\n    emptyPlaceholder = ',',\n    encoder = encodeURIComponent,\n  } = {}\n) => {\n  const escapeRegEx = string => string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  const prefixEscaped = escapeRegEx(objectPrefix);\n  const postfixEscaped = escapeRegEx(objectPostfix);\n  const separatorEscaped = escapeRegEx(separator);\n  const emptyEscaped = escapeRegEx(emptyPlaceholder);\n  if (typeof object === 'string') object = JSON.parse(object);\n  const string = Object.values(object)\n    .map(function encodeValues(value) {\n      if (value && typeof value === 'object') {\n        return (\n          objectPrefix +\n          Object.values(value)\n            .map(encodeValues)\n            .join(separator) +\n          objectPostfix\n        );\n      }\n      if (!value && value !== 0) value = emptyPlaceholder;\n      else {\n        if (value === true) value = 1;\n        value = encoder(value);\n        if (\n          value.match(\n            `(${postfixEscaped})|(${prefixEscaped})|(${separatorEscaped})|(${emptyEscaped})`\n          )\n        )\n          throw `Defined postfix, prefix or separator exists in source! (value: ${value})`;\n      }\n      return value;\n    })\n    .join(separator)\n    .replace(\n      // last postfixes are not needed\n      new RegExp(`${postfixEscaped}+$`),\n      ''\n    )\n    .replace(\n      // prefix / postfix can act as sole separator\n      new RegExp(`${separatorEscaped}${prefixEscaped}`, 'g'),\n      objectPrefix\n    )\n    .replace(\n      new RegExp(`${postfixEscaped}${separatorEscaped}`, 'g'),\n      objectPostfix\n    );\n  return string;\n};\n\nexport const deserialize = (\n  string,\n  template,\n  {\n    objectPrefix = '=',\n    objectPostfix = '+',\n    separator = '&',\n    emptyPlaceholder = ',',\n    decoder = decodeURIComponent,\n  } = {}\n) => {\n  let arrays = [[]];\n  let curArray = arrays[0];\n  let curValue = '';\n  for (const c of string) {\n    if ([separator, objectPrefix, objectPostfix].indexOf(c) !== -1) {\n      if (curValue === emptyPlaceholder) curArray.push('');\n      else if (curValue) curArray.push(decoder(curValue));\n      curValue = '';\n\n      if (c === objectPrefix) {\n        curArray = [];\n        arrays.push(curArray);\n      } else if (c === objectPostfix) {\n        arrays.pop();\n        arrays[arrays.length - 1].push(curArray);\n        curArray = arrays[arrays.length - 1];\n      }\n      continue;\n    }\n    curValue += c;\n  }\n  // if last objectPostfixes are missing\n  if (curValue === emptyPlaceholder) curArray.push('');\n  else if (curValue) curArray.push(decoder(curValue));\n\n  while (arrays.length > 1) arrays[arrays.length - 2].push(arrays.pop());\n\n  // remove outer array\n  arrays = arrays[0];\n\n  if (template) {\n    let object;\n    if (Array.isArray(template)) object = [...template];\n    else object = { ...template };\n    const mapValuesToObject = (object, array) => {\n      Object.entries(object).forEach(([key, value], i) => {\n        if (value && typeof value === 'object') {\n          mapValuesToObject(value, array[i]);\n          return;\n        }\n\n        object[key] = array[i];\n        if (typeof value === 'number') object[key] = parseFloat(array[i]) || 0;\n        else if (typeof value === 'boolean') object[key] = !!array[i];\n      });\n    };\n    mapValuesToObject(object, arrays);\n    return object;\n  }\n\n  return arrays;\n};\n"],"names":["string","template","objectPrefix","objectPostfix","separator","emptyPlaceholder","decoder","decodeURIComponent","arrays","curArray","curValue","c","indexOf","push","pop","length","object","mapValuesToObject","array","Object","entries","forEach","i","key","value","parseFloat","Array","isArray","encoder","encodeURIComponent","escapeRegEx","replace","prefixEscaped","postfixEscaped","separatorEscaped","emptyEscaped","JSON","parse","values","map","encodeValues","join","match","RegExp"],"mappings":"+fA0D2B,SACzBA,EACAC,KAYA,uBALI,SALFC,aAAAA,aAAe,UACfC,cAAAA,aAAgB,UAChBC,UAAAA,aAAY,UACZC,iBAAAA,aAAmB,UACnBC,QAAAA,aAAUC,qBAGRC,EAAS,CAAC,IACVC,EAAWD,EAAO,GAClBE,EAAW,wrBACCV,kBAAQ,KAAbW,WACoD,IAAzD,CAACP,EAAWF,EAAcC,GAAeS,QAAQD,GAerDD,GAAYC,GAdND,IAAaL,EAAkBI,EAASI,KAAK,IACxCH,GAAUD,EAASI,KAAKP,EAAQI,IACzCA,EAAW,GAEPC,IAAMT,EAERM,EAAOK,KADPJ,EAAW,IAEFE,IAAMR,IACfK,EAAOM,MACPN,EAAOA,EAAOO,OAAS,GAAGF,KAAKJ,GAC/BA,EAAWD,EAAOA,EAAOO,OAAS,KAUxC,IAHIL,IAAaL,EAAkBI,EAASI,KAAK,IACxCH,GAAUD,EAASI,KAAKP,EAAQI,IAElCF,EAAOO,OAAS,GAAGP,EAAOA,EAAOO,OAAS,GAAGF,KAAKL,EAAOM,OAM9D,IAAIE,EADN,OAFAR,EAASA,EAAO,GAEZP,GAIwB,SAApBgB,EAAqBD,EAAQE,GACjCC,OAAOC,QAAQJ,GAAQK,QAAQ,WAAeC,OAAbC,OAAKC,OAChCA,GAA0B,iBAAVA,EAClBP,EAAkBO,EAAON,EAAMI,KAIjCN,EAAOO,GAAOL,EAAMI,GACC,iBAAVE,EAAoBR,EAAOO,GAAOE,WAAWP,EAAMI,KAAO,EAC3C,kBAAVE,IAAqBR,EAAOO,KAASL,EAAMI,OAG/DL,CAd6BD,EAAzBU,MAAMC,QAAQ1B,aAAwBA,QACvBA,GAaOO,GACnBQ,GAGFR,eAvHgB,SACvBQ,sBAOI,SALFd,aAAAA,aAAe,UACfC,cAAAA,aAAgB,UAChBC,UAAAA,aAAY,UACZC,iBAAAA,aAAmB,UACnBuB,QAAAA,aAAUC,qBAGNC,EAAc,SAAA9B,UAAUA,EAAO+B,QAAQ,sBAAuB,SAC9DC,EAAgBF,EAAY5B,GAC5B+B,EAAiBH,EAAY3B,GAC7B+B,EAAmBJ,EAAY1B,GAC/B+B,EAAeL,EAAYzB,GAyCjC,MAxCsB,iBAAXW,IAAqBA,EAASoB,KAAKC,MAAMrB,IACrCG,OAAOmB,OAAOtB,GAC1BuB,IAAI,SAASC,EAAahB,GACzB,GAAIA,GAA0B,iBAAVA,EAClB,OACEtB,EACAiB,OAAOmB,OAAOd,GACXe,IAAIC,GACJC,KAAKrC,GACRD,EAGJ,GAAKqB,GAAmB,IAAVA,GAIZ,IAFc,IAAVA,IAAgBA,EAAQ,IAC5BA,EAAQI,EAAQJ,IAERkB,UACAT,QAAoBD,QAAmBE,QAAsBC,OAGnE,uEAAwEX,WATjDA,EAAQnB,EAWnC,OAAOmB,IAERiB,KAAKrC,GACL2B,QAEC,IAAIY,OAAUV,QACd,IAEDF,QAEC,IAAIY,UAAUT,EAAmBF,EAAiB,KAClD9B,GAED6B,QACC,IAAIY,UAAUV,EAAiBC,EAAoB,KACnD/B"}